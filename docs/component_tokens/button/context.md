# Создание компонентных токенов для кнопки: подход по контексту

## Задача

Я дизайнер и у меня задача создать компонент "кнопка". Мне нужно определить все токены, которые будут использоваться для стилизации этого компонента, используя контекстный подход.

## Выбор подхода

Я выбираю подход по контексту, потому что мне важно понимать, **где и как** используется компонент. Кнопка — это конкретный компонент, и я создаю токены специально для него, ссылаясь напрямую на базовый слой.

## Почему семантический слой не нужен?

При контекстном подходе семантический слой **не нужен**, потому что:

1. **Нет переиспользования**: Токены кнопки используются только в кнопке. Использовать `color.button.primary` в таблице или бейдже — это плохая практика, которая путает дизайнеров.

2. **1:1 дублирование**: Если семантический слой специфичен для компонента (например, `semantic_context.color.button.*`), он просто дублирует компонентный слой без добавления абстракции.

3. **Прямая связь с базой**: Компонентные токены могут напрямую ссылаться на базовый слой, что проще и понятнее.

## Процесс создания токенов

### Шаг 1: Анализ структуры кнопки

Сначала я думаю о том, из каких частей состоит кнопка:
- Фон (background) — может быть разным для разных состояний
- Текст (text) — должен быть читаемым на фоне
- Граница (border) — опционально
- Состояния: default, hover, active, disabled
- Варианты: primary, secondary
- Размеры: small, medium, large

### Шаг 2: Выбор базовых токенов для primary кнопки

Для primary кнопки я выбираю токены напрямую из базового слоя:
- `base.color.blue.500` — основной цвет для фона и границы
- `base.color.blue.600` — для hover состояния
- `base.color.blue.700` — для active состояния
- `base.color.white` — для текста на цветном фоне
- `base.color.gray.400` — для disabled состояния

### Шаг 3: Выбор токенов для secondary кнопки

Для secondary кнопки:
- `base.color.gray.100` — нейтральный фон
- `base.color.gray.200` — для hover
- `base.color.gray.300` — для active
- `base.color.gray.900` — для текста
- `base.color.gray.300` — для границы

### Шаг 4: Spacing и размеры

Для отступов я выбираю напрямую из базового слоя:
- `base.spacing.md` для горизонтального padding
- `base.spacing.sm` для вертикального padding
- `base.spacing.sm` для gap между иконкой и текстом

Для размеров варьирую padding и font_size:
- Small: `base.spacing.sm` + `base.typography.font_size.sm`
- Medium: `base.spacing.md` + `base.typography.font_size.base`
- Large: `base.spacing.lg` + `base.typography.font_size.lg`

### Шаг 5: Typography

Для типографики:
- `base.typography.font_size.base` — стандартный размер
- `base.typography.font_weight.medium` — средний вес
- `base.typography.line_height.normal` — стандартная высота строки

### Шаг 6: Border radius и shadow

- `base.border_radius.md` — умеренное скругление
- `base.shadow.sm` для default, `base.shadow.md` для hover

## Примеры использования

```json
{
  "button.primary.background.default": "{base.color.blue.500}",
  "button.primary.text.default": "{base.color.white}",
  "button.padding.x": "{base.spacing.md}"
}
```

## Преимущества подхода

1. **Простота**: Прямая связь с базовым слоем, нет промежуточного слоя
2. **Понятность**: Ясно видно, какие базовые значения используются
3. **Быстрота**: Не нужно создавать семантический слой
4. **Специфичность**: Токены максимально специфичны для компонента

## Недостатки подхода

1. **Нет абстракции**: Если нужно изменить цвет всех primary кнопок, нужно менять в компонентных токенах
2. **Сложнее White Label**: Для разных брендов нужно менять компонентные токены
3. **Дублирование**: Если несколько компонентов используют одинаковые значения, они дублируются
4. **Проблемы масштабирования**: При большом количестве компонентов (50+) изменения становятся очень трудоемкими

⚠️ **Подробнее о проблемах масштабирования:** см. [Масштабирование контекстного подхода](../../../context_approach_scaling.md)

## Размышления

Когда я создаю компонентные токены при контекстном подходе, я мыслю так: "Это кнопка, значит мне нужны токены специально для кнопки." Я выбираю базовые токены напрямую, без промежуточного семантического слоя.

Этот подход особенно хорош для быстрого прототипирования и когда компоненты не переиспользуют токены между собой. Однако для White Label решений или когда нужна единая точка изменений, лучше использовать другие подходы (роли или функциональность).

⚠️ **Важно:** При большом количестве компонентов (50+) контекстный подход создает серьезные проблемы масштабирования. Подробнее см. [Масштабирование контекстного подхода](../../../context_approach_scaling.md).

## Сравнение с другими подходами

- **Функциональный**: `action.primary` может использоваться в button, link, icon-button → есть переиспользование → семантический слой нужен
- **По ролям**: `brand.primary` может использоваться в button, logo, header → есть переиспользование → семантический слой нужен
- **По иерархии**: `level_1.action` может использоваться в разных компонентах → есть переиспользование → семантический слой нужен
- **По контексту**: `button.primary` используется только в button → нет переиспользования → семантический слой не нужен
