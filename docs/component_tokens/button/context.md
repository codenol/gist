# Создание компонентных токенов для кнопки: подход по контексту

## Задача

Я дизайнер и у меня задача создать компонент "кнопка". Мне нужно определить все токены, которые будут использоваться для стилизации этого компонента, опираясь на семантический слой, организованный по контексту использования.

## Выбор семантики

Я выбираю подход по контексту (`semantic_context`), потому что мне важно понимать, **где и как** используется компонент. Кнопка — это конкретный компонент, и в семантическом слое уже есть готовые токены для кнопок: `color.button.*`, `spacing.button.*`, `typography.button.*`.

## Процесс создания токенов

### Шаг 1: Использование готовых контекстных токенов

Сначала я смотрю, что уже есть в семантическом слое для кнопок:
- `semantic_context.color.button.primary.*` — уже есть все состояния для primary кнопки!
- `semantic_context.color.button.secondary.*` — уже есть все состояния для secondary кнопки!
- `semantic_context.color.button.disabled.*` — уже есть disabled состояние!

Это идеально — мне не нужно думать, какие токены использовать, они уже определены в контексте кнопки.

### Шаг 2: Маппинг состояний

Я просто мапплю состояния компонентных токенов на контекстные:
- `button.primary.background.default` → `semantic_context.color.button.primary.background`
- `button.primary.background.hover` → `semantic_context.color.button.primary.background_hover`
- `button.primary.background.active` → `semantic_context.color.button.primary.background_active`
- `button.primary.text.default` → `semantic_context.color.button.primary.text`

Это очень просто — я просто копирую структуру из семантического слоя.

### Шаг 3: Spacing из контекста

Для spacing тоже все готово:
- `semantic_context.spacing.button.padding_x` — горизонтальный padding для кнопки
- `semantic_context.spacing.button.padding_y` — вертикальный padding для кнопки
- `semantic_context.spacing.button.gap` — gap между элементами в кнопке

Мне не нужно думать о ролях или уровнях — все уже определено в контексте кнопки.

### Шаг 4: Typography из контекста

Для типографики:
- `semantic_context.typography.button.*` — уже есть font_size, font_weight, line_height для кнопки

Все размеры кнопок используют одни и те же токены типографики, потому что они определены в контексте.

### Шаг 5: Border radius и shadow

- `semantic_context.border_radius.button` — скругление для кнопки
- `semantic_context.shadow.button` — тень для кнопки

Все уже определено в контексте!

## Примеры использования

```json
{
  "button.primary.background.default": "{semantic_context.color.button.primary.background}",
  "button.primary.text.default": "{semantic_context.color.button.primary.text}",
  "button.padding.x": "{semantic_context.spacing.button.padding_x}"
}
```

## Преимущества подхода

1. **Простота**: Мне не нужно думать, какие токены использовать — они уже определены в контексте
2. **Специфичность**: Токены максимально специфичны для компонента
3. **Быстрота**: Создание компонентных токенов занимает минимум времени
4. **Понятность**: Любой дизайнер сразу видит, что `color.button.*` — это для кнопок

## Размышления

Когда я создаю компонентные токены, я мыслю так: "Это кнопка, значит мне нужны токены из контекста button." Я просто иду в `semantic_context.color.button.*` и беру оттуда все нужные токены.

Этот подход особенно хорош, когда семантический слой уже содержит контекстные токены для всех основных компонентов. Мне не нужно думать о функциональности, ролях или иерархии — все уже определено в контексте использования.

Однако есть нюанс: если в семантическом слое нет контекстных токенов для какого-то компонента, мне придется их создать сначала, что может быть неудобно. Но для стандартных компонентов, таких как кнопка, это идеальный подход.

