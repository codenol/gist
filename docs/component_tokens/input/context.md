# Создание компонентных токенов для инпута: подход по контексту

## Задача

Я дизайнер и у меня задача создать компонент "инпут" (поле ввода). Мне нужно определить все токены, которые будут использоваться для стилизации этого компонента, используя контекстный подход.

## Выбор подхода

Я выбираю подход по контексту, потому что мне важно понимать, **где и как** используется компонент. Инпут — это конкретный компонент, и я создаю токены специально для него, ссылаясь напрямую на базовый слой.

## Почему семантический слой не нужен?

При контекстном подходе семантический слой **не нужен**, потому что:

1. **Нет переиспользования**: Токены инпута используются только в инпуте. Использовать `color.input.border` в других компонентах — это плохая практика.

2. **1:1 дублирование**: Если семантический слой специфичен для компонента (например, `semantic_context.color.input.*`), он просто дублирует компонентный слой без добавления абстракции.

3. **Прямая связь с базой**: Компонентные токены могут напрямую ссылаться на базовый слой, что проще и понятнее.

## Процесс создания токенов

### Шаг 1: Анализ структуры инпута

Сначала я думаю о том, из каких частей состоит инпут:
- Фон (background) — должен быть чистым и читаемым
- Текст (text) — введенный пользователем текст
- Placeholder — подсказка для пользователя
- Граница (border) — визуальное разделение
- Состояния: default, hover, focus, error, disabled

### Шаг 2: Выбор базовых токенов для фона

Для фона инпута я выбираю напрямую из базового слоя:
- `base.color.white` — основной фон
- `base.color.red.50` — для error состояния
- `base.color.gray.50` — для disabled состояния

### Шаг 3: Выбор токенов для текста

Для текста:
- `base.color.gray.900` — основной текст
- `base.color.gray.500` — для placeholder
- `base.color.gray.400` — для disabled

### Шаг 4: Выбор токенов для границы

Граница инпута должна показывать состояние:
- `base.color.gray.300` — стандартная граница
- `base.color.gray.400` — для hover
- `base.color.blue.500` — для focus (важное состояние!)
- `base.color.red.500` — для error
- `base.color.gray.300` — для disabled

### Шаг 5: Spacing для инпута

Для отступов:
- `base.spacing.md` для горизонтального padding
- `base.spacing.sm` для вертикального padding
- `base.spacing.sm` для gap

### Шаг 6: Typography

Для типографики:
- `base.typography.font_size.base` — стандартный размер
- `base.typography.font_weight.regular` — обычный вес
- `base.typography.line_height.normal` — стандартная высота строки

### Шаг 7: Border radius

- `base.border_radius.md` — умеренное скругление

## Примеры использования

```json
{
  "input.background.default": "{base.color.white}",
  "input.text.default": "{base.color.gray.900}",
  "input.border.focus": "{base.color.blue.500}",
  "input.padding.x": "{base.spacing.md}"
}
```

## Преимущества подхода

1. **Простота**: Прямая связь с базовым слоем
2. **Понятность**: Ясно видно, какие базовые значения используются
3. **Быстрота**: Не нужно создавать семантический слой
4. **Специфичность**: Токены максимально специфичны для компонента

## Недостатки подхода

1. **Нет абстракции**: Если нужно изменить цвет всех инпутов, нужно менять в компонентных токенах
2. **Сложнее White Label**: Для разных брендов нужно менять компонентные токены

## Размышления

Когда я создаю компонентные токены для инпута при контекстном подходе, я мыслю так: "Это инпут, значит мне нужны токены специально для инпута." Я выбираю базовые токены напрямую, без промежуточного семантического слоя.

Особенно важно для инпута правильно обработать состояния focus и error — это ключевые функциональные состояния, которые должны быть четко видны пользователю.
